(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{472:function(t,n,e){"use strict";e.r(n);var s=e(10),o=Object(s.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("p",[this._v("Did you know you can create new Java instance without constructor? That's right, and this feature is brought to you by the Java clone() method. I personally don't like to use it much because it has many pitfalls, and it feels very broken in many ways. You probably can write better \"clone\" by using copy constructor or a static copy factory methods.")]),this._v(" "),n("p",[this._v('Anyrate, here is a unit test that highlights few notes I have gathered about Java clone. Look for the "Note" comments below.')]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('    package atest;\n    \n    import org.junit.Test;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    \n    import static org.hamcrest.Matchers.hasItems;\n    import static org.hamcrest.Matchers.is;\n    import static org.junit.Assert.assertThat;\n    \n    public class CloneTest {\n        @Test\n        public void testFooClone() throws Exception {\n            Foo a = new Foo();\n            Foo b = a.clone();\n    \n            assertThat(a != b, is(true));\n            assertThat(a.constructorCallsCount, is(1));\n            assertThat(a.name, is("foo"));\n            assertThat(b.constructorCallsCount, is(1)); // Note1: Wow, a new instance without calling constructor!\n            assertThat(b.name, is("foo"));\n    \n            a.name = "fooX";\n            assertThat(a.name, is("fooX"));\n            assertThat(b.name, is("foo"));\n    \n            Foo2 c = new Foo2();\n            c.ids.add("a");\n            Foo2 d = c.clone();\n            d.ids.add("b");\n    \n            c.ids.clear();\n            c.ids.add("A");\n    \n            assertThat(c != d, is(true));\n            assertThat(c.constructorCallsCount, is(2));\n            assertThat(c.name, is("foo"));\n            assertThat(d.constructorCallsCount, is(2));\n            assertThat(d.name, is("foo"));\n    \n            assertThat(c.ids, hasItems("A"));\n            assertThat(c.ids.size(), is(1));\n            assertThat(d.ids, hasItems("a", "b"));\n            assertThat(d.ids.size(), is(2));\n        }\n    \n        /** A simple clone examples with simple type fields. */\n        public static class Foo implements Cloneable {\n            static int constructorCallsCount = 0;\n            String name = "foo";\n            public Foo() {\n                constructorCallsCount++;\n            }\n            public Foo clone() {\n                // Note2: Catch checked exception here so client or subclass doesn\'t need to.\n                Foo result = null;\n                try {\n                    result = (Foo)super.clone();\n                } catch (CloneNotSupportedException e) {\n                    throw new RuntimeException("Unable to clone.", e);\n                }\n                return result;\n            }\n        }\n    \n        /** A clone example that needs to fix field afterward super.clone(). */\n        public static class Foo2 extends Foo {\n            List<String> ids = new ArrayList();\n            public Foo2 clone() {\n                Foo2 result = (Foo2)super.clone(); // Note3: Some how, super clone will auto return the correct type!\n                result.ids = new ArrayList(ids);   // Note4: need to fix non-simple field.\n                return result;\n            }\n        }\n    }\n')])])])])}),[],!1,null,null,null);n.default=o.exports}}]);