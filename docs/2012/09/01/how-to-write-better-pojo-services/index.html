<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      How to write better POJO Services &middot; Zemian's Blog
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/2012/09/01/how-to-write-better-pojo-services/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-135626598-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A weblog on software development.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Zemian's Blog</a>
            <small>Life in programming world!</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">How to write better POJO Services</h1>
  <span class="post-date">01 Sep 2012</span>
  <p>In Java, you can easily implement some business logic in Plain Old Java Object (POJO) classes, and then able to run them in a fancy
server or framework without much hassle. There many server/frameworks, such as JBossAS, Spring or Camel etc, that 
would allow you to deploy POJO without even hardcoding to their API. Obviously you would get advance features if you willing to couple to
their API specifics, but even if you do, you can keep these to minimal by encapsulating your own POJO and their API in a wrapper. 
By writing and designing your own application as simple POJO as possible, you will have the most flexible ways in choose a framework or server to 
deploy and run your application. One effective way to write your business logic in these environments is to use <em>Service</em> component. 
In this article I will share few things I learned in writing <em>Services</em>.</p>

<h1 id="what-is-a-service">What is a Service?</h1>

<p>The word <em>Service</em> is overly used today, and it could mean many things to different people. When I say <em>Service</em>, my definition is a software 
component that has minimal of life-cycles such as <code class="language-plaintext highlighter-rouge">init</code>, <code class="language-plaintext highlighter-rouge">start</code>, <code class="language-plaintext highlighter-rouge">stop</code>, and <code class="language-plaintext highlighter-rouge">destroy</code>. You may not need all these
stages of life-cycles in every service you write, but you can simply ignore ones that don’t apply. When writing large application that 
intended for long running such as a server component, definining these life-cycles and ensure they are excuted in proper order is crucial!</p>

<p>I will be walking you through a Java demo project that I have prepared. It’s very basic and it should run as stand-alone. The only dependency it has is
the <a href="http://www.slf4j.org">SLF4J</a> logger. If you don’t know how to use logger, then simply replace them with <code class="language-plaintext highlighter-rouge">System.out.println</code>. However I would strongly 
encourage you to learn how to use logger effectively during application development though. Also if you want to try out the 
<a href="http://www.springsource.org/spring-framework">Spring</a> related demos, then obviously you would need their jars as well.</p>

<h1 id="writing-basic-pojo-service">Writing basic POJO service</h1>

<p>You can quickly define a contract of a Service with life-cycles as below in an interface.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    public interface Service {
        void init();
        void start();
        void stop();
        void destroy();
        boolean isInited();
        boolean isStarted();
    }
</code></pre></div></div>

<p>Developers are free to do what they want in their Service implementation, but you might want to give them an adapter class so that 
they don’t have to re-write same basic logic on each Service. I would provide an abstract service like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    import java.util.concurrent.atomic.*;
    import org.slf4j.*;
    public abstract class AbstractService implements Service {
        protected Logger logger = LoggerFactory.getLogger(getClass());
        protected AtomicBoolean started = new AtomicBoolean(false);
        protected AtomicBoolean inited = new AtomicBoolean(false);
    
        public void init() {
            if (!inited.get()) {
                initService();
                inited.set(true);
                logger.debug("{} initialized.", this);
            }
        }
    
        public void start() {
            // Init service if it has not done so.
            if (!inited.get()) {
                init();
            }
            // Start service now.
            if (!started.get()) {
                startService();
                started.set(true);
                logger.debug("{} started.", this);
            }
        }
    
        public void stop() {
            if (started.get()) {
                stopService();
                started.set(false);
                logger.debug("{} stopped.", this);
            }
        }
    
        public void destroy() {
            // Stop service if it is still running.
            if (started.get()) {
                stop();
            }
            // Destroy service now.
            if (inited.get()) {
                destroyService();
                inited.set(false);
                logger.debug("{} destroyed.", this);
            }
        }
    
        public boolean isStarted() {
            return started.get();
        }
    
        public boolean isInited() {
            return inited.get();
        }
    
        @Override
        public String toString() {
                return getClass().getSimpleName() + "[id=" + System.identityHashCode(this) + "]";
        }
    
        protected void initService() {
        }
    
        protected void startService() {
        }
    
        protected void stopService() {
        }
    
        protected void destroyService() {
        }
    }

</code></pre></div></div>

<p>This abstract class provide the basic of most services needs. It has a logger and states to keep track of the life-cycles. It then delegate new
sets of life-cycle methods so subclass can choose to override. Notice that the <code class="language-plaintext highlighter-rouge">start()</code> method is checking auto calling <code class="language-plaintext highlighter-rouge">init()</code> if it hasn’t 
already done so. Same is done in <code class="language-plaintext highlighter-rouge">destroy()</code> method to the <code class="language-plaintext highlighter-rouge">stop()</code> method. This is important if we’re to use it in a container that only have 
two stages life-cycles invocation. In this case, we can simply invoke <code class="language-plaintext highlighter-rouge">start()</code> and <code class="language-plaintext highlighter-rouge">destroy()</code> to match to our service’s life-cycles.</p>

<p>Some frameworks might go even further and create separate interfaces for each stage of the life-cycles, such as <code class="language-plaintext highlighter-rouge">InitableService</code> or 
<code class="language-plaintext highlighter-rouge">StartableService</code> etc. But I think that would be too much in a typical app. In most of the cases, you want something simple, so I like it just
one interface. User may choose to ignore methods they don’t want, or simply use an adaptor class.</p>

<p>Before we end this section, I would throw in a silly Hello world service that can be used in our demo later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    public class HelloService extends AbstractService {
        public void initService() {
            logger.info(this + " inited.");
        }
        public void startService() {
            logger.info(this + " started.");
        }
        public void stopService() {
            logger.info(this + " stopped.");
        }
        public void destroyService() {
            logger.info(this + " destroyed.");
        }
    }
</code></pre></div></div>

<h1 id="managing-multiple-pojo-services-with-a-container">Managing multiple POJO Services with a container</h1>

<p>Now we have the basic of <em>Service</em> definition defined, your development team may start writing business logic code! Before long, you will have 
a library of your own services to re-use. To be able group and control these services into an effetive way, we want also provide a container 
to manage them. The idea is that we typically want to control and manage multiple services with a container as a group in a higher level. Here 
is a simple implementation for you to get started:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    import java.util.*;
    public class ServiceContainer extends AbstractService {
        private List&lt;Service&gt; services = new ArrayList&lt;Service&gt;();
    
        public void setServices(List&lt;Service&gt; services) {
            this.services = services;
        }
        public void addService(Service service) {
            this.services.add(service);
        }
    
        public void initService() {
            logger.debug("Initializing " + this + " with " + services.size() + " services.");
            for (Service service : services) {
                logger.debug("Initializing " + service);
                service.init();
            }
            logger.info(this + " inited.");
        }
        public void startService() {
                logger.debug("Starting " + this + " with " + services.size() + " services.");
                for (Service service : services) {
                    logger.debug("Starting " + service);
                    service.start();
                }
                logger.info(this + " started.");
        }
        public void stopService() {
                int size = services.size();
                logger.debug("Stopping " + this + " with " + size + " services in reverse order.");
                for (int i = size - 1; i &gt;= 0; i--) {
                    Service service = services.get(i);
                    logger.debug("Stopping " + service);
                    service.stop();
                }
                logger.info(this + " stopped.");
        }
        public void destroyService() {
                int size = services.size();
                logger.debug("Destroying " + this + " with " + size + " services in reverse order.");
                for (int i = size - 1; i &gt;= 0; i--) {
                    Service service = services.get(i);
                    logger.debug("Destroying " + service);
                    service.destroy();
                }
                logger.info(this + " destroyed.");
        }
    }
</code></pre></div></div>

<p>From above code, you will notice few important things:</p>

<ol>
  <li>We extends the AbstractService, so a container is a service itself.</li>
  <li>We would invoke all service’s life-cycles before moving to next. No services will start unless all others are inited.</li>
  <li>We should stop and destroy services in reverse order for most general use cases.</li>
</ol>

<p>The above container implementation is simple and run in synchronized fashion. This mean, you start container, then all services
will start in order you added them. Stop should be same but in reverse order.</p>

<p>I also hope you would able to see that there is plenty of room for you to improve this container as well. For example, you may 
add thread pool to control the execution of the services in asynchronized fashion.</p>

<h1 id="running-pojo-services">Running POJO Services</h1>

<h2 id="running-services-with-a-simple-runner-program">Running services with a simple runner program.</h2>

<p>In the simplest form, we can run our POJO services on our own without any fancy server or frameworks. Java programs start its life from a 
static <code class="language-plaintext highlighter-rouge">main</code> method, so we surely can invoke <code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">start</code> of our services in there. But we also need to address the <code class="language-plaintext highlighter-rouge">stop</code> and <code class="language-plaintext highlighter-rouge">destroy</code>
life-cycles when user shuts down the program (usually by hitting <code class="language-plaintext highlighter-rouge">CTRL+C</code>.) For this, the Java has the <code class="language-plaintext highlighter-rouge">java.lang.Runtime#addShutdownHook()</code>
facility. You can create a simple stand-alone server to bootstrap <em>Service</em> like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    import org.slf4j.*;
    public class ServiceRunner {
        private static Logger logger = LoggerFactory.getLogger(ServiceRunner.class);
    
        public static void main(String[] args) {
            ServiceRunner main = new ServiceRunner();
            main.run(args);
        }
    
        public void run(String[] args) {
            if (args.length &lt; 1)
                throw new RuntimeException("Missing service class name as argument.");
    
            String serviceClassName = args[0];
            try {
                logger.debug("Creating " + serviceClassName);
                Class&lt;?&gt; serviceClass = Class.forName(serviceClassName);
                if (!Service.class.isAssignableFrom(serviceClass)) {
                    throw new RuntimeException("Service class " + serviceClassName + " did not implements " + Service.class.getName());
                }
                Object serviceObject = serviceClass.newInstance();
                Service service = (Service)serviceObject;
    
                registerShutdownHook(service);
    
                logger.debug("Starting service " + service);
                service.init();
                service.start();
                logger.info(service + " started.");
    
                synchronized(this) {
                    this.wait();
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to create and run " + serviceClassName, e);
            }
        }
    
        private void registerShutdownHook(final Service service) {
            Runtime.getRuntime().addShutdownHook(new Thread() {
                public void run() {
                    logger.debug("Stopping service " + service);
                    service.stop();
                    service.destroy();
                    logger.info(service + " stopped.");
                }
            });
        }
    }
</code></pre></div></div>

<p>With abover runner, you should able to run it with this command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java demo.ServiceRunner servicedemo.HelloService
</code></pre></div></div>

<p>Look carefully, and you’ll see that you have many options to run multiple services with above runner. Let me highlight couple:</p>

<ol>
  <li>Improve above runner directly and make all <code class="language-plaintext highlighter-rouge">args</code> for each new service class name, instead of just first element.</li>
  <li>Or write a <code class="language-plaintext highlighter-rouge">MultiLoaderService</code> that will load multiple services you want. You may control argument passing using System Properties.</li>
</ol>

<p>Can you think of other ways to improve this runner?</p>

<h2 id="running-services-with-spring">Running services with Spring</h2>

<p>The Spring framework is an IoC container, and it’s well known to be easy to work POJO, and Spring lets you wire your application 
together. This would be a perfect fit to use in our POJO services. However, with all the features Spring brings, it missed a easy
to use, out of box <em>main</em> program to bootstrap spring config xml context files. But with what we built so far, this is actually an
easy thing to do. Let’s write one of our POJO <em>Service</em> to bootstrap a spring context file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    
    import org.springframework.context.ConfigurableApplicationContext;
    import org.springframework.context.support.FileSystemXmlApplicationContext;
    
    public class SpringService extends AbstractService {
        private ConfigurableApplicationContext springContext;
    
        public void startService() {
            String springConfig = System.getProperty("springContext", "spring.xml);
            springContext = new FileSystemXmlApplicationContext(springConfig);
            logger.info(this + " started.");
        }
        public void stopService() {
            springContext.close();
            logger.info(this + " stopped.");
        }
    }
</code></pre></div></div>

<p>With that simple <code class="language-plaintext highlighter-rouge">SpringService</code> you can run and load any spring xml file. For example try this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -DspringContext=config/service-demo-spring.xml demo.ServiceRunner servicedemo.SpringService
</code></pre></div></div>

<p>Inside the <code class="language-plaintext highlighter-rouge">config/service-demo-spring.xml</code> file, you can easily create our container that hosts one or more service in Spring beans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    
        &lt;bean id="helloService" class="servicedemo.HelloService"&gt;
        &lt;/bean&gt;
    
        &lt;bean id="serviceContainer" class="servicedemo.ServiceContainer" init-method="start" destroy-method="destroy"&gt;
            &lt;property name="services"&gt;
                &lt;list&gt;
                    &lt;ref bean="helloService"/&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    
    &lt;/beans&gt;
</code></pre></div></div>

<p>Notice that I only need to setup <code class="language-plaintext highlighter-rouge">init-method</code> and <code class="language-plaintext highlighter-rouge">destroy-method</code> once on the <code class="language-plaintext highlighter-rouge">serviceContainer</code> bean. You can then add one or more
other service such as the <code class="language-plaintext highlighter-rouge">helloService</code> as much as you want. They will all be started, managed, and then shutdown when you close the
Spring context.</p>

<p>Note that Spring context container did not explicitly have the same life-cycles as our services. The Spring context will automatically
instanciate all your dependency beans, and then invoke all beans who’s <code class="language-plaintext highlighter-rouge">init-method</code> is set. All that is done inside the constructor
of <code class="language-plaintext highlighter-rouge">FileSystemXmlApplicationContext</code>. No explicit init method is called from user. However at the end, during stop of the service, Spring provide
the <code class="language-plaintext highlighter-rouge">springContext#close()</code> to clean things up. Again, they do not differentiate <code class="language-plaintext highlighter-rouge">stop</code> from <code class="language-plaintext highlighter-rouge">destroy</code>. Because of this, we must merge our
<code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">start</code> into Spring’s <code class="language-plaintext highlighter-rouge">init</code> state, and then merge <code class="language-plaintext highlighter-rouge">stop</code> and <code class="language-plaintext highlighter-rouge">destroy</code> into Spring’s <code class="language-plaintext highlighter-rouge">close</code> state. Recall our 
<code class="language-plaintext highlighter-rouge">AbstractService#destory</code> will auto invoke <code class="language-plaintext highlighter-rouge">stop</code> if it hasn’t already done so. So this is trick that we need to understand
in order to use Spring effectively.</p>

<h2 id="running-services-with-jee-app-server">Running services with JEE app server</h2>

<p>In a corporate env, we usually do not have the freedom to run what we want as a stand-alone program. Instead they usually have some 
infrustructure and stricter standard technology stack in place already, such as using a JEE application server. In these situation, the most 
portable way to run POJO services is in a <code class="language-plaintext highlighter-rouge">war</code> web application. In a Servlet web application, you can write a class that implements 
<code class="language-plaintext highlighter-rouge">javax.servlet.ServletContextListener</code> and this will provide you the life-cycles hook via <code class="language-plaintext highlighter-rouge">contextInitialized</code> and <code class="language-plaintext highlighter-rouge">contextDestroyed</code>.
In there, you can instanciate your <code class="language-plaintext highlighter-rouge">ServiceContainer</code> object and call <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">destroy</code> methods accordingly.</p>

<p>Here is an example that you can explore:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package servicedemo;
    import java.util.*;
    import javax.servlet.*;
    public class ServiceContainerListener implements ServletContextListener {
        private static Logger logger = LoggerFactory.getLogger(ServiceContainerListener.class);
        private ServiceContainer serviceContainer;
    
        public void contextInitialized(ServletContextEvent sce) {
            serviceContainer = new ServiceContainer();
            List&lt;Service&gt; services = createServices();
            serviceContainer.setServices(services);
            serviceContainer.start();
            logger.info(serviceContainer + " started in web application.");
        }
    
        public void contextDestroyed(ServletContextEvent sce) {
            serviceContainer.destroy();
            logger.info(serviceContainer + " destroyed in web application.");
        }
    
        private List&lt;Service&gt; createServices() {
            List&lt;Service&gt; result = new ArrayList&lt;Service&gt;();
            // populate services here.
            return result;
        }
    }
</code></pre></div></div>

<p>You may configure above in the <code class="language-plaintext highlighter-rouge">WEB-INF/web.xml</code> like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        &lt;listener&gt;
            &lt;listener-class&gt;servicedemo.ServiceContainerListener&lt;/listener-class&gt;
        &lt;/listener&gt;
    
    &lt;/web-app&gt;
</code></pre></div></div>

<p>The demo provided a placeholder that you must add your services in code. But you can easily make that configurable using the <code class="language-plaintext highlighter-rouge">web.xml</code> for
context parameters.</p>

<p>If you were to use Spring inside a Servlet container, you may directly use their <code class="language-plaintext highlighter-rouge">org.springframework.web.context.ContextLoaderListener</code> 
class that does pretty much same as above, except they allow you to specify their xml configuration file using the
<code class="language-plaintext highlighter-rouge">contextConfigLocation</code> context parameter. That’s how a typical Spring MVC based application is configure. Once you have this setup, you
can experiment our POJO service just as the Spring xml sample given above to test things out. You should see our service in action by
your logger output.</p>

<p>PS: Actually what we described here are simply related to Servlet web application, and not JEE specific. So you can use Tomcat server just
fine as well.</p>

<h1 id="the-importance-of-services-life-cycles-and-its-real-world-usage">The importance of Service’s life-cycles and it’s real world usage</h1>

<p>All the information I presented here are not novelty, nor a killer design pattern. In fact they have been used in many popular open source projects.
However, in my past experience at work, folks always manage to make these extremely complicated, and worse case is that they completely disregard the 
importance of life-cycles when writing services. It’s true that not everything you going to write needs to be fitted into a service, but if you find
the need, please do pay attention to them, and take good care that they do invoked properly. The last thing you want is to exit JVM without clean up
in services that you allocated precious resources for. These would become more disastrous if you allow your application to be dynamically reloaded during
deployment without exiting JVM, in which will lead to system resources leakage.</p>

<p>The above <em>Service</em> practice has been put into use in the <a href="https://bitbucket.org/timemachine/scheduler">TimeMachine</a> project. In fact, if you 
look at the <code class="language-plaintext highlighter-rouge">timemachine.scheduler.service.SchedulerEngine</code>, it would just be a container of many <a href="https://bitbucket.org/timemachine/scheduler/src/15f066cc6dad/timemachine-scheduler/src/main/java/timemachine/scheduler/service">services</a> 
running together. And that’s how user can extend the scheduler functionalities as well, by writing a <em>Service</em>. You can load these services dynamically by a simple properties file.</p>

</div>


<div class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/09/20/world-of-php/">
            The World of PHP Development
            <small>20 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/19/multiple-jquery/">
            How to Load Multiple jQuery
            <small>19 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/08/15/switched-to-vuepress/">
            Switched Blogging to VuePress
            <small>15 Aug 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
