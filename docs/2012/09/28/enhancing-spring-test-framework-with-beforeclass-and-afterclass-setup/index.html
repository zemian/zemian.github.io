<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Enhancing Spring Test Framework with beforeClass and afterClass setup &middot; Zemian's Blog
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/2012/09/28/enhancing-spring-test-framework-with-beforeclass-and-afterclass-setup/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-135626598-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A weblog on software development.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Zemian's Blog</a>
            <small>Life in programming world!</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Enhancing Spring Test Framework with beforeClass and afterClass setup</h1>
  <span class="post-date">28 Sep 2012</span>
  <h1 id="how-to-allow-instance-methods-to-run-as-junit-beforeclass-behavior">How to allow instance methods to run as JUnit BeforeClass behavior</h1>

<p>JUnit allows you to setup methods on the class level once before and after all tests methods invocation. However, by design on purpose that they restrict this to only <em>static</em> methods using <code class="language-plaintext highlighter-rouge">@BeforeClass</code> and <code class="language-plaintext highlighter-rouge">@AfterClass</code> annotations. For example this simple demo shows the typical Junit setup:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.AfterClass;
    import org.junit.BeforeClass;
    import org.junit.Test;
    
    public class DemoTest {
    
        @Test
        public void testOne() {
            System.out.println("Normal test method #1.");
        }
    
        @Test
        public void testTwo() {
            System.out.println("Normal test method #2.");
        }
    
        @BeforeClass
        public static void beforeClassSetup() {
            System.out.println("A static method setup before class.");
        }
    
        @AfterClass
        public static void afterClassSetup() {
            System.out.println("A static method setup after class.");
        }
    }
</code></pre></div></div>

<p>And above should result the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    A static method setup before class.
    Normal test method #1.
    Normal test method #2.
    A static method setup after class.
</code></pre></div></div>

<p>This usage is fine for most of the time, but there are times you want to use non-static methods to setup the test. I will show you a more detailed use case later, but for now, let’s see how we can solve this naughty problem with JUnit first. We can solve this by making the test
implements a Listener that provide the before and after callbacks, and we will need to digg into JUnit to detect this Listener to invoke our methods. This is a solution I came up with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    
    @RunWith(InstanceTestClassRunner.class)
    public class Demo2Test implements InstanceTestClassListener {
    
        @Test
        public void testOne() {
            System.out.println("Normal test method #1");
        }
    
        @Test
        public void testTwo() {
            System.out.println("Normal test method #2");
        }
    
        @Override
        public void beforeClassSetup() {
            System.out.println("An instance method setup before class.");
        }
    
        @Override
        public void afterClassSetup() {
            System.out.println("An instance method setup after class.");
        }
    }
</code></pre></div></div>

<p>As stated above, our Listener is a simple contract:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    public interface InstanceTestClassListener {
        void beforeClassSetup();
        void afterClassSetup();
    }
</code></pre></div></div>

<p>Our next task is to provide the JUnit runner implementation that will trigger the setup methods.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.runner.notification.RunNotifier;
    import org.junit.runners.BlockJUnit4ClassRunner;
    import org.junit.runners.model.InitializationError;
    
    public class InstanceTestClassRunner extends BlockJUnit4ClassRunner {
    
        private InstanceTestClassListener instanceSetupListener;
    
        public InstanceTestClassRunner(Class&lt;?&gt; klass) throws InitializationError {
            super(klass);
        }
    
        @Override
        protected Object createTest() throws Exception {
            Object test = super.createTest();
            // Note that JUnit4 will call this createTest() multiple times for each
            // test method, so we need to ensure to call "beforeClassSetup" only once.
            if (test instanceof InstanceTestClassListener &amp;&amp; instanceSetupListener == null) {
                instanceSetupListener = (InstanceTestClassListener) test;
                instanceSetupListener.beforeClassSetup();
            }
            return test;
        }
    
        @Override
        public void run(RunNotifier notifier) {
            super.run(notifier);
            if (instanceSetupListener != null)
                instanceSetupListener.afterClassSetup();
        }
    }
</code></pre></div></div>

<p>Now we are in business. If we run above test, it should give us similar result, but this time we are using instance methods instead!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    An instance method setup before class.
    Normal test method #1
    Normal test method #2
    An instance method setup after class.
</code></pre></div></div>

<h1 id="a-concrete-use-case-working-with-spring-test-framework">A concrete use case: Working with Spring Test Framework</h1>

<p>Now let me show you a real use case with above. If you use Spring Test Framework, you would normally setup a test like this so that you may have test fixture injected as member instance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration
    public class SpringDemoTest {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    }
</code></pre></div></div>

<p>You would also need a spring xml under that same package for above to run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
         &lt;bean id="myList" class="java.util.ArrayList"&gt;
            &lt;constructor-arg&gt;
                &lt;list&gt;
                    &lt;value&gt;one&lt;/value&gt;
                    &lt;value&gt;two&lt;/value&gt;
                &lt;/list&gt;
            &lt;/constructor-arg&gt;
         &lt;/bean&gt;
    &lt;/beans&gt;
</code></pre></div></div>

<p>Pay very close attention to member instance <code class="language-plaintext highlighter-rouge">List&lt;String&gt; myList</code>. When running JUnit test, that field will be injected by Spring, and it can be used in any test method. However, if you ever want a one time setup of some code and get a reference to a Spring injected field, then you are in bad luck. This is because the JUnit <code class="language-plaintext highlighter-rouge">@BeforeClass</code> will force your method to be static; and if you make your field static, Spring injection won’t work in your test!</p>

<p>Now if you are a frequent Spring user, you should know that Spring Test Framework already provided a way for you to handle this type of use case. Here is a way for you to do class level setup with Spring’s style:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    import org.springframework.test.context.TestContext;
    import org.springframework.test.context.TestExecutionListeners;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    import org.springframework.test.context.support.AbstractTestExecutionListener;
    import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
    
    @RunWith(SpringJUnit4ClassRunner.class)
    @TestExecutionListeners(listeners = {
            DependencyInjectionTestExecutionListener.class, 
            SpringDemo2Test.class})
    @ContextConfiguration
    public class SpringDemo2Test extends AbstractTestExecutionListener {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    
        @Override
        public void afterTestClass(TestContext testContext) {
            List&lt;?&gt; list = testContext.getApplicationContext().getBean("myList", List.class);
            assertThat((String)list.get(0), is("one"));
        }
    
        @Override
        public void beforeTestClass(TestContext testContext) {
            List&lt;?&gt; list = testContext.getApplicationContext().getBean("myList", List.class);
            assertThat((String)list.get(1), is("two"));
        }
    }
</code></pre></div></div>

<p>As you can see, Spring offers the <code class="language-plaintext highlighter-rouge">@TestExecutionListeners</code> annotation to allow you to write any Listener, and in it you will have a reference to the <code class="language-plaintext highlighter-rouge">TestContext</code> which has the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> for you to get to the injected field reference. This works, but I find it not very elegant. It forces you to look up the bean, while your injected field is already available as field. But you can’t use it unless you go through the <code class="language-plaintext highlighter-rouge">TestContext</code> parameter.</p>

<p>Now if you mix the solution we provided in the beginning, we will see a more prettier test setup. Let’s see it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    
    import deng.junitdemo.InstanceTestClassListener;
    
    @RunWith(SpringInstanceTestClassRunner.class)
    @ContextConfiguration
    public class SpringDemo3Test implements InstanceTestClassListener {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    
        @Override
        public void beforeClassSetup() {
            assertThat((String)myList.get(0), is("one"));
        }
    
        @Override
        public void afterClassSetup() {
            assertThat((String)myList.get(1), is("two"));
        }
    }
</code></pre></div></div>

<p>Now JUnit only allow you to use single <code class="language-plaintext highlighter-rouge">Runner</code>, so we must extends the Spring’s version to insert what we did before.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import org.junit.runner.notification.RunNotifier;
    import org.junit.runners.model.InitializationError;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    
    import deng.junitdemo.InstanceTestClassListener;
    
    public class SpringInstanceTestClassRunner extends SpringJUnit4ClassRunner {
    
        private InstanceTestClassListener instanceSetupListener;
    
        public SpringInstanceTestClassRunner(Class&lt;?&gt; clazz) throws InitializationError {
            super(clazz);
        }
    
        @Override
        protected Object createTest() throws Exception {
            Object test = super.createTest();
            // Note that JUnit4 will call this createTest() multiple times for each
            // test method, so we need to ensure to call "beforeClassSetup" only once.
            if (test instanceof InstanceTestClassListener &amp;&amp; instanceSetupListener == null) {
                instanceSetupListener = (InstanceTestClassListener) test;
                instanceSetupListener.beforeClassSetup();
            }
            return test;
        }
    
        @Override
        public void run(RunNotifier notifier) {
            super.run(notifier);
            if (instanceSetupListener != null)
                instanceSetupListener.afterClassSetup();
        }
    }
</code></pre></div></div>

<p>That should do the trick. Running the test will give use this output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    12:58:48 main INFO  org.springframework.test.context.support.AbstractContextLoader:139 | Detected default resource location "classpath:/deng/junitdemo/spring/SpringDemo3Test-context.xml" for test class [deng.junitdemo.spring.SpringDemo3Test].
    12:58:48 main INFO  org.springframework.test.context.support.DelegatingSmartContextLoader:148 | GenericXmlContextLoader detected default locations for context configuration [ContextConfigurationAttributes@74b23210 declaringClass = 'deng.junitdemo.spring.SpringDemo3Test', locations = '{classpath:/deng/junitdemo/spring/SpringDemo3Test-context.xml}', classes = '{}', inheritLocations = true, contextLoaderClass = 'org.springframework.test.context.ContextLoader'].
    12:58:48 main INFO  org.springframework.test.context.support.AnnotationConfigContextLoader:150 | Could not detect default configuration classes for test class [deng.junitdemo.spring.SpringDemo3Test]: SpringDemo3Test does not declare any static, non-private, non-final, inner classes annotated with @Configuration.
    12:58:48 main INFO  org.springframework.test.context.TestContextManager:185 | @TestExecutionListeners is not present for class [class deng.junitdemo.spring.SpringDemo3Test]: using defaults.
    12:58:48 main INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 | Loading XML bean definitions from class path resource [deng/junitdemo/spring/SpringDemo3Test-context.xml]
    12:58:48 main INFO  org.springframework.context.support.GenericApplicationContext:500 | Refreshing org.springframework.context.support.GenericApplicationContext@44c9d92c: startup date [Sat Sep 29 12:58:48 EDT 2012]; root of context hierarchy
    12:58:49 main INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory:581 | Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@73c6641: defining beans [myList,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy
    12:58:49 Thread-1 INFO  org.springframework.context.support.GenericApplicationContext:1025 | Closing org.springframework.context.support.GenericApplicationContext@44c9d92c: startup date [Sat Sep 29 12:58:48 EDT 2012]; root of context hierarchy
    12:58:49 Thread-1 INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory:433 | Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@73c6641: defining beans [myList,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy
</code></pre></div></div>

<p>Obviously the output shows nothing interesting here, but the test should run with all assertion passed. The point is that now we have a more elegant way to invoking a before and after test setup that are at class level, and they can be instance methods to allow Spring injection.</p>

<h1 id="download-the-demo-code">Download the demo code</h1>

<p>You may get above demo code in a working Maven project from <a href="https://bitbucket.org/saltnlight5/sandbox/src/8d545b15fbbd/junit-examples">my sandbox</a>.</p>

</div>


<div class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/09/20/world-of-php/">
            The World of PHP Development
            <small>20 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/19/multiple-jquery/">
            How to Load Multiple jQuery
            <small>19 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/08/15/switched-to-vuepress/">
            Switched Blogging to VuePress
            <small>15 Aug 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
